import wic.api.pythonapi as api
import polus.plugins as pp
from pathlib import Path
import yaml
import logging
import re
import shutil
from utils import GITHUB_TAG, JSON_FILENAME, get_params


# Initialize the logger
logging.basicConfig(
    format="%(asctime)s - %(name)-8s - %(levelname)-8s - %(message)s",
    datefmt="%d-%b-%y %H:%M:%S",
)
logger = logging.getLogger("WIC Python API")
logger.setLevel(logging.INFO)


class Segmentation_Workflow:
    """
    A CWL segmentation pipeline.
    """

    def __init__(
        self,
        name: str,
        file_pattern: str,
        out_file_pattern: str,
        image_pattern: str,
        map_directory: str,
        ff_pattern: str,
        df_pattern: str,
        group_by: str,
    ):

        self.name = name
        self.file_pattern = file_pattern
        self.out_file_pattern = out_file_pattern
        self.map_directory = map_directory
        self.ff_pattern = ff_pattern
        self.df_pattern = df_pattern
        self.group_by = group_by
        self.wic_path = api._WIC_PATH
        self.PATH = Path(self.wic_path.parent).joinpath(Path(__file__).parts[-3])
        self.cwl_path, self.workflow_path = self._create_directories()
        self.image_pattern = image_pattern

    def _create_directories(self) -> None:
        """Create directories for WIC outputs"""
        cwl_path = self.PATH.joinpath("cwl_adapters")
        cwl_path.mkdir(parents=True, exist_ok=True)
        workflow_path = self.PATH.joinpath("workflows").resolve()
        workflow_path.mkdir(exist_ok=True)
        return cwl_path, workflow_path

    def _clean(self) -> None:
        """Cleaning of redundant directories generating on running CWL"""
        logger.info("Cleaning directories!!!")
        dir_names = ("autogenerated", "cachedir", "cwl_adapters", "RUNS", "provenance")
        for d in self.wic_path.iterdir():
            if d.name.endswith(dir_names):
                shutil.rmtree(d)

        for d in self.PATH.iterdir():
            if d.name.endswith(dir_names):
                shutil.rmtree(d)

        return

    def _move_outputs(self) -> None:
        """Transfer outputs from the WIC directory to the workflow path"""
        logger.info("Move outputs to workflow path!!!")
        for d in self.wic_path.iterdir():
            if d.name.endswith("outdir"):
                shutil.move(d, self.workflow_path)
        return

    def _camel(self, name: str) -> str:
        """Convert Plugin name to camel case."""
        name = re.sub(r"(_|-)+", " ", name).title().replace(" ", "")
        return "".join([name[0].upper(), name[1:]])

    def _string_after_period(self, x):
        """Get a string after period."""
        match = re.search(r"\.(.*)", x)
        if match:
            # Get the part after the period
            return f".*.{match.group(1)}"
        else:
            return ""

    def _add_backslash_before_parentheses(self, x):
        """Add backlsash to."""
        # Define the regular expression pattern to match parenthesis
        pattern_1 = r"(\()|(\))"
        # Use re.sub() to add a backslash before starting and finishing parenthesis
        result = re.sub(pattern_1, r"\\\1\2", x)
        pattern_2 = r"\d"
        result = (
            result.split("_c")[0]
            + "_c{c:d}"
            + re.sub(pattern_2, "", result.split("_c")[1])
        )
        return result

    def create_step(self, url: str) -> api.Step:
        """Generate Plugin Class Name from Plugin name in manifest."""
        manifest = pp.submit_plugin(url)
        plugin_version = str(manifest.version)
        cwl_tool = pp.get_plugin(self._camel(manifest.name), plugin_version).save_cwl(
            self.cwl_path.joinpath(f"{self._camel(manifest.name)}.cwl")
        )
        step = api.Step(cwl_tool)
        return step

    def manifest_urls(self, x: str) -> str:
        """URLs on GitHub for plugin manifests"""

        urls = {
            "bbbc_download": f"{GITHUB_TAG}/saketprem/polus-plugins/bbbc_download/utils/bbbc-download-plugin/plugin.json",
            "file_renaming": f"{GITHUB_TAG}/PolusAI/polus-plugins/f20a2f75264d59af78cfb40b4c3cec118309f7ec/formats/file-renaming-plugin/plugin.json",
            "ome_converter": f"{GITHUB_TAG}/hamshkhawar/image-tools/basecontainer_omecontainer/formats/ome-converter-plugin/plugin.json",
            "estimate_flatfield": f"{GITHUB_TAG}/nishaq503/image-tools/fix/basic/regression/basic-flatfield-estimation-tool/plugin.json",
            "apply_flatfield": f"{GITHUB_TAG}/PolusAI/image-tools/master/transforms/images/apply-flatfield-tool/plugin.json",
            "kaggle_nuclei_segmentation": f"{GITHUB_TAG}/hamshkhawar/image-tools/kaggle-nuclei_seg/segmentation/kaggle-nuclei-segmentation/plugin.json",
        }
        return urls[x]

    def modify_cwl(self) -> None:
        """Modify CWL to incorporate environmental variables and permission access"""
        for f in list(self.cwl_path.rglob("*.cwl")):
            if f.name == "BbbcDownload.cwl":
                with Path.open(f, "r") as file:
                    bbc_config = yaml.safe_load(file)
                    bbc_config["requirements"]["NetworkAccess"] = {
                        "networkAccess": True
                    }

                with Path.open(f, "w") as out_file:
                    yaml.dump(bbc_config, out_file)
            if f.name == "OmeConverter.cwl":
                with Path.open(f, "r") as file:
                    ome_config = yaml.safe_load(file)
                    ome_config["requirements"]["EnvVarRequirement"] = {
                        "envDef": {"HOME": "/home/polusai"}
                    }
                with Path.open(f, "w") as out_file:
                    yaml.dump(ome_config, out_file)
        return

    def workflow(self) -> None:
        """
        A CWL segmentation pipeline.
        """
        # BBBCDownload
        bbbc = self.create_step(self.manifest_urls("bbbc_download"))
        bbbc.name = self.name
        bbbc.outDir = Path("bbbc.outDir")

        # Renaming plugin
        rename = self.create_step(self.manifest_urls("file_renaming"))
        rename.filePattern = self.file_pattern
        rename.outFilePattern = self.out_file_pattern
        rename.mapDirectory = self.map_directory
        rename.inpDir = bbbc.outDir
        rename.outDir = Path("rename.outDir")

        # OMEConverter
        ome_converter = self.create_step(self.manifest_urls("ome_converter"))
        ome_converter.filePattern = self._string_after_period(self.out_file_pattern)
        ome_converter.fileExtension = ".ome.tif"
        ome_converter.inpDir = rename.outDir
        ome_converter.outDir = Path("ome_converter.outDir")

        # Estimate Flatfield
        estimate_flatfield = self.create_step(self.manifest_urls("estimate_flatfield"))
        estimate_flatfield.inpDir = ome_converter.outDir
        estimate_flatfield.filePattern = self.image_pattern
        estimate_flatfield.groupBy = self.group_by
        estimate_flatfield.getDarkfield = True
        estimate_flatfield.outDir = Path("estimate_flatfield.outDir")

        # # Apply Flatfield
        apply_flatfield = self.create_step(self.manifest_urls("apply_flatfield"))
        apply_flatfield.imgDir = ome_converter.outDir
        apply_flatfield.imgPattern = self.image_pattern
        apply_flatfield.ffDir = estimate_flatfield.outDir
        apply_flatfield.ffPattern = self.ff_pattern
        apply_flatfield.dfPattern = self.df_pattern
        apply_flatfield.outDir = Path("apply_flatfield.outDir")

        ## Kaggle Nuclei Segmentation
        kaggle_nuclei_segmentation = self.create_step(
            self.manifest_urls("kaggle_nuclei_segmentation")
        )
        kaggle_nuclei_segmentation.inpDir = apply_flatfield.outDir
        kaggle_nuclei_segmentation.filePattern = self.image_pattern
        kaggle_nuclei_segmentation.outDir = Path("kaggle_nuclei_segmentation.outDir")

        logger.info("Segmentation Workflow Started")
        steps = [
            bbbc,
            rename,
            ome_converter,
            estimate_flatfield,
            apply_flatfield,
            kaggle_nuclei_segmentation,
        ]

        workflow = api.Workflow(steps, "experiment", self.workflow_path)
        # Saving CLT for plugins
        workflow._save_all_cwl(overwrite=True)
        # Adding environmental variables for bbbc_download and ome_converter plugin
        self.modify_cwl()
        # Save yaml to run CWL tool
        workflow._save_yaml()
        # Compile and run using WIC python API
        workflow.compile(run_local=True, overwrite=False)
        # print(workflow.yml_path)
        # clean autognerated directories
        self._clean()
        self._move_outputs()
        logger.info("Finished Runing Segmentation Workflow")

        return


if __name__ == "__main__":
    seg_params = get_params(JSON_FILENAME, "BBBC039")
    model = Segmentation_Workflow(**seg_params)
    model.workflow()
