import logging
import re
import shutil
from pathlib import Path
import typing
import yaml

from sophios.api.pythonapi import Step, Workflow
import polus.tools.plugins as pp
from image.workflows.utils import OUT_PATH,MANIFEST_URLS


# Initialize the logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class CWLSegmentationWorkflow:
    """
    A CWL Nuclear Segmentation pipeline to process imaging datasets.
    
    Attributes:
        work_dir: Path to working directory.
        name: Name of the imaging dataset.
        file_pattern: Pattern for parsing raw filenames.
        out_file_pattern: Desired format for output filenames.
        image_pattern: Pattern for parsing intensity image filenames.
        seg_pattern: Pattern to parse segmentation image filenames.
        ff_pattern: Filename pattern for selecting flatfield components.
        df_pattern: Filename pattern for selecting darkfield components.
        group_by: Variables used for grouping the file pattern.
        background_correction: Flag to enable background correction.
        map_directory: Enable mapping of folder names.
        out_dir: Directory for saving outputs.
    """
    def __init__(
        self,
        work_dir: Path,
        name: str,
        file_pattern: str,
        out_file_pattern: str,
        image_pattern: str,
        seg_pattern: str,
        ff_pattern: typing.Optional[str] = '',
        df_pattern: typing.Optional[str] = '',
        group_by: typing.Optional[str] = '',
        map_directory: typing.Optional[bool] = False,
        background_correction: typing.Optional[bool] = False,
        out_dir: typing.Optional[Path] = OUT_PATH
    ):
        self.name = name
        self.file_pattern = file_pattern
        self.out_file_pattern = out_file_pattern
        self.image_pattern = image_pattern
        self.seg_pattern = seg_pattern
        self.ff_pattern = ff_pattern
        self.df_pattern = df_pattern
        self.group_by = group_by
        self.map_directory = map_directory
        self.background_correction = background_correction
        self.out_dir = out_dir
        self.work_dir = work_dir
        self.adapters_path = self.work_dir.joinpath("cwl_adapters")
        if not self.adapters_path.exists():
            self.adapters_path.mkdir(exist_ok=True, parents=True)

    def _move_outputs(self) -> None:
        """Move output files and directories to the specified output directory."""
        logger.info("Moving directories and JSON files to output directory.")
        dir_names = {"autogenerated", "cachedir", "provenance", "outdir"}
        
        # Move specified directories
        for directory in self.work_dir.iterdir():
            if directory.name in dir_names:
                shutil.move(directory, self.out_dir)
        
        # Move JSON files
        for json_file in self.work_dir.rglob("*.json"):
            shutil.move(json_file, self.out_dir)

    @staticmethod
    def _to_camel_case(name: str) -> str:
        """Convert a plugin name to camel case."""
        return re.sub(r"(_|-)+", " ", name).title().replace(" ", "")

    @staticmethod
    def _extract_file_extension(pattern: str) -> str:
        """Extract and return the string after a period in the pattern."""
        match = re.search(r"\.(.*)", pattern)
        return f".*.{match.group(1)}" if match else ""

    @staticmethod
    def _escape_parentheses(pattern: str) -> str:
        """Escape parentheses and generate patterns for flatfield and darkfield correction."""
        pattern = re.sub(r"(\()|(\))", r"\\\1\2", pattern)
        return pattern.split("_c")[0] + "_c{c:d}" + re.sub(r"\d", "", pattern.split("_c")[1])

    def create_step(self, plugin_url: str) -> Step:
        """Create a step for the workflow based on the plugin manifest."""
        manifest = dict(pp.submit_plugin(plugin_url))
        plugin_version = str(manifest['version'])
        cwl_tool = pp.get_plugin(self._to_camel_case(manifest['name']), plugin_version).save_cwl(
            self.adapters_path.joinpath(f"{self._to_camel_case(manifest['name'])}.cwl")
        )
        self._modify_cwl()
        return Step(cwl_tool)

    def _get_manifest_url(self, plugin_name: str) -> str:
        """Retrieve the URL for the plugin manifest from GitHub."""
        return MANIFEST_URLS.get(plugin_name, "")

    def _modify_cwl(self) -> None:
        """Modify CWL files to include environmental variables and permissions."""
        for cwl_file in self.adapters_path.rglob("*.cwl"):
            if "cwl" in cwl_file.name:
                try:
                    with cwl_file.open("r") as file:
                        config = yaml.safe_load(file)
                        config.setdefault("requirements", {})
                        config["requirements"]["NetworkAccess"] = {"networkAccess": True}
                        config["requirements"]["EnvVarRequirement"] = {"envDef": {"HOME": "/home/polusai"}}
                    with cwl_file.open("w") as out_file:
                        yaml.dump(config, out_file)
                except FileNotFoundError:
                    logger.error(f"Error processing file: {cwl_file}")

    def workflow(self) -> None:
        """Execute the CWL nuclear segmentation pipeline."""
        logger.info("Starting CWL nuclear segmentation workflow.")

        # Step: BBBC Download
        bbbc = self.create_step(self._get_manifest_url("bbbc_download"))
        bbbc.name = self.name
        bbbc.outDir = Path("bbbc.outDir")

        # Step: File Renaming
        rename = self.create_step(self._get_manifest_url("file_renaming"))
        rename.filePattern = self.file_pattern
        rename.outFilePattern = self.out_file_pattern
        rename.mapDirectory = self.map_directory
        rename.inpDir = bbbc.outDir
        rename.outDir = Path("rename.outDir")

        # Step: OME Converter
        ome_converter = self.create_step(self._get_manifest_url("ome_converter"))
        ome_converter.filePattern = self._extract_file_extension(self.out_file_pattern)
        ome_converter.fileExtension = ".ome.tif"
        ome_converter.inpDir = rename.outDir
        ome_converter.outDir = Path("ome_converter.outDir")

        # Optional: Background correction
        if self.background_correction:
            estimate_flatfield = self.create_step(self._get_manifest_url("estimate_flatfield"))
            estimate_flatfield.inpDir = ome_converter.outDir
            estimate_flatfield.filePattern = self.image_pattern
            estimate_flatfield.groupBy = self.group_by
            estimate_flatfield.getDarkfield = True
            estimate_flatfield.outDir = Path("estimate_flatfield.outDir")

            apply_flatfield = self.create_step(self._get_manifest_url("apply_flatfield"))
            apply_flatfield.imgDir = ome_converter.outDir
            apply_flatfield.imgPattern = self.image_pattern
            apply_flatfield.ffDir = estimate_flatfield.outDir
            apply_flatfield.ffPattern = self.ff_pattern
            apply_flatfield.dfPattern = self.df_pattern
            apply_flatfield.outDir = Path("apply_flatfield.outDir")

        # Step: Kaggle Nuclei Segmentation
        kaggle_segmentation = self.create_step(self._get_manifest_url("kaggle_nuclei_segmentation"))
        kaggle_segmentation.inpDir = apply_flatfield.outDir if self.background_correction else ome_converter.outDir
        kaggle_segmentation.filePattern = self.image_pattern
        kaggle_segmentation.outDir = Path("kaggle_nuclei_segmentation.outDir")

        # Step: FTL Label Plugin
        ftl_plugin = self.create_step(self._get_manifest_url("ftl_plugin"))
        ftl_plugin.inpDir = kaggle_segmentation.outDir
        ftl_plugin.connectivity = "1"
        ftl_plugin.binarizationThreshold = 0.5
        ftl_plugin.outDir = Path("ftl_plugin.outDir")

        # Run the workflow
        steps = [
            bbbc, 
            rename, ome_converter,
            estimate_flatfield if self.background_correction else None,
            apply_flatfield if self.background_correction else None,
            kaggle_segmentation,
            ftl_plugin

        ]

        workflow = Workflow(steps, f"{self.name}_workflow")
        # Compile and run using WIC python API
        workflow.compile()
        workflow.run()
        self._move_outputs()
        logger.info("Completed CWL nuclear segmentation workflow.")
        return
